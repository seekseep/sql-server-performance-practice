-- =============================================================================
-- レベル1: 基礎編 - 単一テーブルの基本操作とインデックス効果の体感
-- =============================================================================
-- 
-- 【学習目標】
-- 1. SQL実行時間の測定方法を覚える
-- 2. インデックスがある場合とない場合の性能差を体感する
-- 3. 実行計画の基本的な見方を覚える
--
-- 【実行前の準備】
-- 以下のコマンドを実行して、詳細な情報を表示する設定にしてください：
-- SET STATISTICS IO ON;    -- ディスク読み取り回数を表示
-- SET STATISTICS TIME ON;  -- 実行時間を表示
-- 
-- =============================================================================

-- 【ステップ1】データ量の確認
-- まず、どれくらいのデータがあるかを確認します
-- =============================================================================

PRINT '=== データ量の確認 ===';

-- 各テーブルの行数を確認
SELECT 'Employee' TableName, COUNT(*) RowCount FROM Employee
UNION ALL
SELECT 'Customer', COUNT(*) FROM Customer  
UNION ALL
SELECT 'Product', COUNT(*) FROM Product
UNION ALL
SELECT 'ProductStock', COUNT(*) FROM ProductStock
UNION ALL
SELECT 'ReceivingAchievement', COUNT(*) FROM ReceivingAchievement
UNION ALL
SELECT 'ReceivingAchievementDetail', COUNT(*) FROM ReceivingAchievementDetail;

-- =============================================================================
-- 【ステップ2】基本的な検索（全件取得）
-- インデックスを使わない基本的な検索から始めます
-- =============================================================================

PRINT '=== ステップ2: 基本的な検索（全件取得） ===';

-- 2-1. 全従業員の取得（小さなテーブル）
-- 【予想】高速（数ミリ秒）
PRINT '2-1. 全従業員取得開始';
SELECT Id, Name FROM Employee;
PRINT '2-1. 完了';

-- 2-2. 全製品在庫の取得（大きなテーブル）  
-- 【予想】時間がかかる（数百ミリ秒〜数秒）
PRINT '2-2. 全製品在庫取得開始';
SELECT COUNT(*) TotalProductStock FROM ProductStock;
PRINT '2-2. 完了';

-- 2-3. 受領実績詳細の件数取得（最も大きなテーブル）
-- 【予想】最も時間がかかる
PRINT '2-3. 受領実績詳細件数取得開始';
SELECT COUNT(*) TotalReceivingDetails FROM ReceivingAchievementDetail;
PRINT '2-3. 完了';

-- =============================================================================
-- 【ステップ3】主キー検索（インデックスが効く検索）
-- 主キー（Id）での検索は常に高速です
-- =============================================================================

PRINT '=== ステップ3: 主キー検索（高速） ===';

-- 3-1. 特定の従業員を検索
-- 【予想】非常に高速（1ミリ秒未満）
PRINT '3-1. 従業員ID=1の検索開始';
SELECT Id, Name FROM Employee WHERE Id = 1;
PRINT '3-1. 完了';

-- 3-2. 特定の製品在庫を検索
-- 【予想】非常に高速（主キーのおかげ）
PRINT '3-2. 製品在庫ID=1の検索開始';
SELECT Id, ProductId, WarehouseId, Used FROM ProductStock WHERE Id = 1;
PRINT '3-2. 完了';

-- 3-3. 存在しないIDの検索
-- 【予想】高速（インデックスですぐに「無い」と判断できる）
PRINT '3-3. 存在しない従業員ID=99999の検索開始';
SELECT Id, Name FROM Employee WHERE Id = 99999;
PRINT '3-3. 完了';

-- =============================================================================
-- 【ステップ4】非インデックス列での検索（遅い検索の体感）
-- インデックスがない列で検索すると全行をチェックする必要があります
-- =============================================================================

PRINT '=== ステップ4: 非インデックス列での検索（低速） ===';

-- 4-1. 従業員名での検索（インデックスなし）
-- 【予想】主キー検索より遅い（全行をチェック）
PRINT '4-1. 従業員名での検索開始';
SELECT Id, Name FROM Employee WHERE Name = 'employee_1';
PRINT '4-1. 完了';

-- 4-2. 使用済み在庫の検索（インデックスなし）  
-- 【予想】かなり遅い（大量データを全行チェック）
PRINT '4-2. 使用済み在庫検索開始';
SELECT COUNT(*) UsedStockCount FROM ProductStock WHERE Used = 1;
PRINT '4-2. 完了';

-- 4-3. 利用可能な在庫の検索（インデックスなし）
-- 【予想】上記と同程度に遅い
PRINT '4-3. 利用可能在庫検索開始';
SELECT COUNT(*) AvailableStockCount FROM ProductStock WHERE Used = 0;
PRINT '4-3. 完了';

-- =============================================================================
-- 【ステップ5】範囲検索の性能比較
-- 主キーでの範囲検索 vs 非インデックス列での範囲検索
-- =============================================================================

PRINT '=== ステップ5: 範囲検索の性能比較 ===';

-- 5-1. 主キーでの範囲検索（高速）
-- 【予想】高速（インデックスで範囲を効率的に特定）
PRINT '5-1. 従業員ID 1-10の範囲検索開始';
SELECT Id, Name FROM Employee WHERE Id BETWEEN 1 AND 10;
PRINT '5-1. 完了';

-- 5-2. 製品在庫IDでの範囲検索（高速）
-- 【予想】高速（主キーのおかげ）
PRINT '5-2. 製品在庫ID 1-1000の範囲検索開始';
SELECT COUNT(*) FROM ProductStock WHERE Id BETWEEN 1 AND 1000;
PRINT '5-2. 完了';

-- 5-3. 非インデックス列での範囲検索（低速）
-- 【予想】遅い（全行をチェックして条件に合うかを判定）
PRINT '5-3. 製品ID 1-10の製品在庫検索開始';
SELECT COUNT(*) FROM ProductStock WHERE ProductId BETWEEN 1 AND 10;
PRINT '5-3. 完了';

-- =============================================================================
-- 【ステップ6】実行計画の確認方法
-- どのような処理が行われているかを確認します
-- =============================================================================

PRINT '=== ステップ6: 実行計画の確認 ===';

-- 実行計画を表示する設定
SET SHOWPLAN_ALL ON;

-- 6-1. 主キー検索の実行計画（Index Seekになる）
SELECT Id, Name FROM Employee WHERE Id = 1;

-- 6-2. 非インデックス列検索の実行計画（Table Scanになる）  
SELECT COUNT(*) FROM ProductStock WHERE Used = 1;

-- 実行計画表示を終了
SET SHOWPLAN_ALL OFF;

-- =============================================================================
-- 【結果の見方と次のステップ】
-- =============================================================================

PRINT '=== レベル1完了 ===';
PRINT '統計情報を確認してください：';
PRINT '1. 「logical reads」: ディスクから読み取ったページ数（少ないほど良い）';
PRINT '2. 「CPU time」: CPU使用時間（ミリ秒）';  
PRINT '3. 「elapsed time」: 実際の実行時間（ミリ秒）';
PRINT '';
PRINT '【観察ポイント】';
PRINT '- 主キー検索は logical reads が少ない';
PRINT '- 全表検索は logical reads が多い';
PRINT '- データ量が多いほど差が顕著になる';
PRINT '';
PRINT '【次のレベルへ】';
PRINT 'インデックスを追加して性能改善を体感しましょう！';
PRINT 'level2-index-effects.sql を実行してください。';

-- 統計情報表示を終了
SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;

-- =============================================================================
-- 【補足説明】
-- =============================================================================
-- 
-- ■ なぜ主キー検索が速いのか？
-- 主キー（Id列）には自動的にクラスター化インデックスが作成されます。
-- これは「辞書の索引」のようなもので、データを素早く見つけられます。
-- 
-- ■ なぜ非インデックス列検索が遅いのか？  
-- インデックスがない列では、全ての行を一つずつチェックする必要があります。
-- これを「全表スキャン（Table Scan）」と呼びます。
--
-- ■ logical reads とは？
-- データベースがディスクから読み取ったページ（8KBの単位）の数です。
-- 少ないほど効率的な検索ができています。
--
-- ■ 実行計画の基本
-- - Index Seek: インデックスを使って効率的に検索（速い）
-- - Table Scan: 全ての行をチェック（遅い）
-- - Index Scan: インデックス全体をチェック（中程度）
-- 
-- =============================================================================